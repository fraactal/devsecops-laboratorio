name: Laboratorio Final DevSecOps

on:
  push: 
    branches: ["**"]          # se ejecuta en cada commit a cualquier rama

permissions:
  contents: read
  security-events: write
  pull-requests: read

jobs:
  anlisis-SAST:
    runs-on : ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  
      
      - name: Variables de Entorno y contexto
        run: |
          echo "Verificando Variables..."
          echo "Repositorio              : $GITHUB_REPOSITORY"
          echo "Actor                    : $GITHUB_ACTOR"
          echo "Evento                   : $GITHUB_EVENT_NAME"
          echo "Branch                   : $GITHUB_REF_NAME"
          echo "Commit                   : $GITHUB_SHA"

      #- name: Sonar API check - project visibility
      #  env:
      #    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      #  run: |
      #    set -e
      #    ORG="laboratorio1"
      #    PROJ="fraactal_devsecops-laboratorio"
      #    URL="https://sonarcloud.io/api/projects/search?organization=${ORG}&projects=${PROJ}"
      #    echo "GET $URL"
      #    CODE=$(curl -s -o resp.json -w "%{http_code}" -u "$SONAR_TOKEN:" "$URL")
      #    echo "HTTP $CODE"; head -c 400 resp.json || true
      #    test "$CODE" = "200"

      - name: analisis de Codigo SAST
        id: AnalisisSAST
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          #GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Github lo configura de forma automatica, no es necesario incluirlo 
          SONAR_TOKEN:  ${{ secrets.SONAR_TOKEN }} 


      - name: Esperar procesamiento (Compute Engine)
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -e
          PROJ="fraactal_devsecops-laboratorio"
          BR="${GITHUB_REF_NAME}"

          echo "Esperando CE para ${PROJ} (branch=${BR}) ..."
          ATTEMPTS=50
          SLEEP=6
          for i in $(seq 1 $ATTEMPTS); do
            URL="https://sonarcloud.io/api/ce/activity?component=${PROJ}&branch=${BR}&onlyCurrents=true"
            JSON=$(curl -s -u "$SONAR_TOKEN:" "$URL")
            STATUS=$(echo "$JSON" | jq -r '.tasks[0].status // "NONE"')
            TASKID=$(echo "$JSON" | jq -r '.tasks[0].id // ""')
            echo "Intento $i: CE task=${TASKID:-<none>} status=${STATUS}"

            case "$STATUS" in
              SUCCESS)
                echo "CE OK (procesado)."
                break
                ;;
              FAILED|CANCELED)
                echo "CE terminó en estado $STATUS"; echo "$JSON" | jq .
                exit 1
                ;;
              NONE|PENDING|IN_PROGRESS|null|"")
                # sigue esperando
                ;;
              *)
                echo "Estado desconocido: $STATUS (seguiré esperando)"
                ;;
            esac
            sleep $SLEEP
          done

      - name: Resultado SAST - Bloqueao x vulnerabilidades Crit/Alta/Media
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -e
          ORG="laboratorio1"
          PROJ="fraactal_devsecops-laboratorio"
          BR="${GITHUB_REF_NAME}"
          BASE="https://sonarcloud.io/api/issues/search?organization=${ORG}&projectKey=${PROJ}&types=VULNERABILITY&statuses=OPEN,CONFIRMED,REOPENED&branch=${BR}&ps=1"

          get_total () { 
            curl -s -u "$SONAR_TOKEN:" "${BASE}&severities=$1" | jq -r '.total'
          }

          C=$(get_total CRITICAL)
          H=$(get_total MAJOR)
          M=$(get_total MINOR)

          echo "Vulnerabilidades abiertas (branch=$BR):"
          echo "  CRITICAL: $C"
          echo "  MAJOR   : $H"
          echo "  MINOR   : $M"

          TOTAL=$((C+H+M))
          if [ "$TOTAL" -gt 0 ]; then
            echo "SAST FAIL: Se encontraron vulnerabilidades Crit/Alta/Media = $TOTAL"
            echo "Ver: https://sonarcloud.io/dashboard?id=${PROJ}&branch=${BR}&resolved=false"
            #exit 1    # Quitar para dejar analisis que continue en caso de hallar vulnerabilidades
          else
            echo "SAST OK: Sin vulnerabilidades Crit/Alta/Media abiertas."
          fi

# === SCA (OWASP Dependency-Check) ===
  anlisis-SCA:
    needs: anlisis-SAST
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Exporta rutas basadas en RUNNER_TEMP para usarlas en todo el job
      - name: Definir rutas SCA
        run: |
          echo "DC_DATA_DIR=$RUNNER_TEMP/dc" >> "$GITHUB_ENV"
          echo "DC_REPORT_DIR=$RUNNER_TEMP/reports" >> "$GITHUB_ENV"

      - name: Preparar carpetas
        run: |
          mkdir -p "${DC_DATA_DIR}" "${DC_REPORT_DIR}"

      # 1) Update de la DB con retry y purge si es necesario
      - name: Dependency-Check DB update (retry + purge si falla)
        id: dcupdate
        env:
          NVD_API_KEY: ${{ secrets.NVD_API_KEY }}
        continue-on-error: true
        run: |
          set -e
          # limpia locks viejos
          find "${DC_DATA_DIR}" -type f \( -name "*.lck" -o -name "*.lock" \) -delete || true

          update_once () {
            docker run --rm \
              -v "${DC_DATA_DIR}:/usr/share/dependency-check/data" \
              -v "${DC_REPORT_DIR}:/report" \
              owasp/dependency-check:9.0.10 \
              --updateonly \
              ${NVD_API_KEY:+--nvdApiKey "$NVD_API_KEY"} \
              --log /report/dc-update.log
          }

          echo ">> Intento 1 de update"
          set +e; update_once; RC=$?; set -e
          if [ $RC -ne 0 ]; then
            echo "Update falló (rc=$RC). Purge de la cache y reintento..."
            docker run --rm \
              -v "${DC_DATA_DIR}:/usr/share/dependency-check/data" \
              -v "${DC_REPORT_DIR}:/report" \
              owasp/dependency-check:9.0.10 \
              --purge \
              --log /report/dc-purge.log || true

            # segunda pasada de update tras purge
            set +e; update_once; RC=$?; set -e
          fi

          echo "update_rc=$RC" >> "$GITHUB_OUTPUT"
          echo "Contenido DC_DATA_DIR:"
          ls -la "${DC_DATA_DIR}" || true

      # 2) Scan sin update; si la DB no está, saldrá con error y lo veremos en logs
      - name: Dependency-Check Scan (fail on CVSS >= 4.0)
        id: dcscan
        continue-on-error: true
        run: |
          set -e
          docker run --rm \
            -v "${{ github.workspace }}:/src" \
            -v "${DC_DATA_DIR}:/usr/share/dependency-check/data" \
            -v "${DC_REPORT_DIR}:/report" \
            owasp/dependency-check:9.0.10 \
            --noupdate \
            --scan /src \
            --format HTML \
            --format JSON \
            --format SARIF \
            --out /report \
            --project "${GITHUB_REPOSITORY}@${GITHUB_REF_NAME}" \
            --failOnCVSS 4.0 \
            --log /report/dc-scan.log
          echo "scan_rc=$?" >> "$GITHUB_OUTPUT"
          echo "Reportes generados:"
          ls -la "${DC_REPORT_DIR}" || true

      - name: Mostrar resumen (si existe JSON)
        if: always()
        run: |
          REPORT="${DC_REPORT_DIR}/dependency-check-report.json"
          if [ -f "$REPORT" ]; then
            jq -r '
              [ .dependencies[]?.vulnerabilities[]?
                | ( .severity // .cvssv3?.baseSeverity // .cvssv2?.severity // "UNKNOWN" )
              ] | group_by(.) | map({ severity: .[0], count: length })
            ' "$REPORT"
          else
            echo "No se encontró $REPORT"
          fi
          echo "== Logs =="
          for f in dc-update.log dc-purge.log dc-scan.log; do
            test -f "${DC_REPORT_DIR}/$f" && { echo "--- $f ---"; tail -n 200 "${DC_REPORT_DIR}/$f"; } || true
          done

      - name: Subir reportes como artefacto
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-check-reports
          path: |
            ${{ env.DC_REPORT_DIR }}/dependency-check-report.html
            ${{ env.DC_REPORT_DIR }}/dependency-check-report.json
            ${{ env.DC_REPORT_DIR }}/dependency-check-report.sarif
            ${{ env.DC_REPORT_DIR }}/dc-update.log
            ${{ env.DC_REPORT_DIR }}/dc-purge.log
            ${{ env.DC_REPORT_DIR }}/dc-scan.log

      - name: Publicar SARIF en Code Scanning
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ env.DC_REPORT_DIR }}/dependency-check-report.sarif

      # Bloquear el job si el scan detectó CVSS >= 4.0
      #- name: Enforzar fallo si hubo vulnerabilidades MEDIUM+
      #  if: ${{ steps.dcscan.outcome == 'failure' }}
      #  run: |
      #    echo "Falla SCA: se detectaron vulnerabilidades CVSS >= 4.0"
      #    # exit 1   # descomenta para bloquear


      
  Build-Docker-Trivy-Scan:
    needs: anlisis-SCA    # Se comenta porque OWASP Dependency Check demora mucho
    #needs: anlisis-SAST    
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: reddit-clone
      IMAGE_TAG: ${{ github.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: buildx-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            buildx-${{ runner.os }}-

      - name: Build image (local)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          load: true        # no publica, carga en daemon local
          tags: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new

      - name: Move build cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Mostrar imágenes locales
        run: |
          echo "Listado de imágenes locales:"
          docker images | head -n 20

      # Image Security Scan con Trivy 
      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}
          restore-keys: |
            trivy-db-

      - name: Ejecutar Trivy 
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: sarif
          output: trivy-image.sarif
          vuln-type: 'os,library'
          severity: 'MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: false
          exit-code: '1'              # <- falla el job si hay Medium


      - name: Publicar SARIF en Code Scanning
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-image.sarif

      - name: Generar reporte tabular de Trivy
        if: always()
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: table
          output: trivy-image.txt
          vuln-type: 'os,library'
          severity: 'MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: false

      - name: Subir reportes de Trivy
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-image-reports-${{ github.sha }}
          path: |
            trivy-image.sarif
            trivy-image.txt



#1. Clonación del repositorio.
#2. Ejecutar SAST -> Usar SonarCloud o herramienta similar.
#3. Ejecutar SCA ->Usar Dependency Check o similar.
#4. Construcción de la Imagen Docker.
#5. Image Security -> Usar Trivy o similar.
  
